function [C,idx,BW]=step2_ConstructClosedContour(bw)
% Get contour vertix coordinates. 
%
% INPUT:
%   - bw    : binary image containing two boundary lines of the cortex.
%             This image is generated by the 'step1_GetCortexBoundaries' 
%             function.
%
% OUTPUT:
%   - C     : (N+1)-by-2 ordered list of point coordinates defining a 2D 
%			  closed contour, where N is the total number of points. Note 
%			  that the first (C(1,:)) and last (C(end,:)) points must be 
%			  the same.
%   - idx   : 4-by-1 vector containing indices to the end-points of
%             the boundary lines in C. First two entries are the indices
%             of the first and last points of the boundary segment with 
%			  the lowest average curvature (--> white matter boundary).
%	- BW 	: binary image of the same size as bw where the endpoints of
%			  the boundary lines have been connected by straight line
%			  segments to form a closed contour.
%
% AUTHOR: Anton Semechko (a.semechko@gmail.com)
% DATE: Feb.2014
%


% Find the end-points of the contour
L=bwlabel(bw);
m=max(L(:));
if m~=2
    error('Unable to find cortex boundaries')
end
bw1=bwmorph(L==1,'endpoints');
bw2=bwmorph(L==2,'endpoints');

idx1=find(bw1(:));
idx2=find(bw2(:));
clear L bw1 bw2

[y1,x1]=ind2sub(size(bw),idx1);
[y2,x2]=ind2sub(size(bw),idx2);

if numel(x1)~=2 || numel(x2)~=2
    error('Unable to detect end-points of the cortex boundary lines')
end

% Match the end-points from the two lines based on proximity
yx1=[y1(:),x1(:)];
yx2=[y2(:),x2(:)];

D1=bsxfun(@minus,yx1,yx2(1,:));
D1=sum(D1.^2,2);
[D1_min,idx1]=min(D1);

D2=bsxfun(@minus,yx1,yx2(2,:));
D2=sum(D2.^2,2);
[D2_min,idx2]=min(D2);

% Get the coordinates of the lines
if D1_min<=D2_min
    if idx1==2
        yx1=[yx1(2,:); yx1(1,:)];
    end
else
    if idx2==2
        yx1=[yx1(2,:); yx1(1,:)];
        yx2=[yx2(2,:); yx2(1,:)];
    end
end
% yx1(1,:) --> yx2(1,:) --> yx2(2,:) --> yx1(2,:) 

% Close the contour
d1=yx2(1,:)-yx1(1,:); d1_l2=norm(d1);
d2=yx1(2,:)-yx2(2,:); d2_l2=norm(d2);

t1=linspace(0,d1_l2,3*d1_l2);
t2=linspace(0,d2_l2,3*d2_l2);

l1=bsxfun(@times,d1/d1_l2,t1(:));
l1=bsxfun(@plus,yx1(1,:),l1);

l2=bsxfun(@times,d2/d2_l2,t2(:));
l2=bsxfun(@plus,yx2(2,:),l2);

l1=round(l1); l1=sub2ind(size(bw),l1(:,1),l1(:,2));
l2=round(l2); l2=sub2ind(size(bw),l2(:,1),l2(:,2));

BW=bw;
BW(l1)=true;
BW(l2)=true;

% Get the coordinates of the contour points
C=bwboundaries(BW,'noholes');
C=fliplr(C{1});

% Make sure that the contour has a counter-clockwise orientation. Ordering 
% is counter-clockwise if area enclosed by the contour is positive and 
% clockwise otherwise. Note that the ordering appears clockwise, however, 
% when viewed in image coordinates because the direction of the y-axis is 
% reversed.
A=PolyArea(C);
if A<0, C=flipud(C); end
C(end,:)=[];

% Find the indices of the end-points of the cortex boundaries
for i=1:2

    idx1=C(:,1)==yx1(1,2) & C(:,2)==yx1(1,1); idx1=find(idx1,1);
    idx2=C(:,1)==yx1(2,2) & C(:,2)==yx1(2,1); idx2=find(idx2,1);
    
    C1=circshift(C,[1-idx1 0]);
    C2=circshift(C,[1-idx2 0]);
    
    idx2=C1(:,1)==yx1(2,2) & C1(:,2)==yx1(2,1); idx2=find(idx2,1);
    idx1=C2(:,1)==yx1(1,2) & C2(:,2)==yx1(1,1); idx1=find(idx1,1);
    
    if idx2<idx1
        C=C1;
        idx=[1 idx2];
    else
        C=C2;
        idx=[1 idx1];
    end
    
    idx3=C(:,1)==yx2(1,2) & C(:,2)==yx2(1,1); idx3=find(idx3,1);
    idx4=C(:,1)==yx2(2,2) & C(:,2)==yx2(2,1); idx4=find(idx4,1);
    
    if idx3<idx(2) % contour was traced in the opposite direction 
        yx=yx1;
        yx1=yx2;
        yx2=yx;
    else
        break
    end
     
end

% Remove the contour connecting the end-points of two different lines
a=[idx sort([idx3 idx4],'ascend')];
C((a(4)+1):end,:)=[];
C((a(2)+1):(a(3)-1),:)=[];
idx=[idx idx(2)+1 size(C,1)];
C=[C;C(1,:)];

% Simplify the contour
[~,i_rem]=DecimatePoly(C,[50 1],false);
i_rem(idx)=false;
a=zeros(size(i_rem));
a(idx)=1:4;

C=C(~i_rem,:);
a(i_rem)=[];
idx=[find(a==1,1) find(a==2,1) find(a==3,1) find(a==4,1)];

% Compute the average curvature of the two lines and put the one with the 
% lowest average curvature first
k1=PolyLineCurvature(C(idx(1):idx(2),:));
k2=PolyLineCurvature(C(idx(3):idx(4),:));
if k2<k1
    C=[C(idx(3):idx(4),:); C(idx(1):idx(2),:)];
    C=[C;C(1,:)];
    idx=[1 idx(4)-idx(3)+1 idx(4)-idx(3)+2 size(C,1)-1];
end


function A=PolyArea(C)
% Polygon area

dx=C(1:(end-1),1)-C(2:end,1);
dy=C(2:end,2)+C(1:(end-1),2);
A=sum(dx.*dy)/2;


